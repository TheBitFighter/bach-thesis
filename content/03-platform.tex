%!TEX spellcheck
%!TEX root = ../bachelor_paper.tex
\documentclass[../bachelor_paper.tex]{subfiles}
\graphicspath{{\subfix{images/}}}
\begin{document}

\chapter{Platform}
    \label{ch:plat}

\section{Instruction Set Architecture}
We chose the open RISC-V \ac{ISA} as our target. RISC-V has seen a surge in popularity in recent years, as its usage is completely free and open. This has lead to a flourishing ecosystem of open IPs from different institutions with different goals in mind. The architecture is a basic RISC like load/store architecture featuring an unprivileged and privileged specification \cite{RISCVInstructionSet2022}.

\section{Base IP}
We base our design on the Pulpissimo microcontroller IP provided by the ETH Z\"urich, and University of Bologna \cite{schiavoneQuentinUltraLowPowerPULPissimo2018}. The core used in the design is the CV32E40P, formerly known and here (for simplicity) referred to as RI5CY \cite{gautschiNearThresholdRISCVCore2017}. RI5CY is a 32-bit core with a single-issue, in-order, 4-stage pipeline implementing the RV32IM[F]C instruction set. Floating point support can be enabled and disabled ([F]) depending on requirements towards the core. We will have floating point support enabled as dedicated hardware \acp{FPU} have become rather common even in embedded \acp{SOC}. RI5CY does support several nonstandard extensions to the RISC-V \ac{ISA} such has \acl{HWL}, dot product multiplication (also referred to as multiply-accumulate), nonstandard floating point formats, as well as packed SIMD operations.

\subsection{Pipeline}
As seen in figure \ref{fig:plat/base/blockdia}, RI5CY consists of 4 pipeline stages. Stage one is an instruction fetch stage using a 4 entry prefetch buffer as well as a \ac{HWL} controller, which we will go into detail about in section \ref{sub:plat/ip/ctrl}. Stage 2 is the instruction decode stage, containing the RISC-V decoder as well as the register file and \ac{HWL} registers. Stage 3 is the execute stage featuring an \ac{ALU} for arithmetic and logic operations except multiplication, as well as a multi-cycle multiplication unit which can also perform multiply accumulate operations. Additionally, if enabled, the exec stage also contains the \ac{FPU} which we will go further into in section \ref{sub:plat/ip/fpu}. The 4th and final pipeline stage contains the load/store unit as well as the register write-back. The main design goal of the RI5CY core was to provide a low power, high performance \ac{DSP} focused core \cite{gautschiNearThresholdRISCVCore2017}, which is reflected in the chosen set of optimizations.

\begin{figure}
    \centering
    %\includesvg[width=0.6\columnwidth]{ri5cy_blockdiagram}
    \includegraphics[width=0.6\columnwidth]{placeholder}
    \caption{Block diagram of the RI5CY pipeline}
    \label{fig:plat/base/blockdia}
\end{figure}

\subsection{Storage architecture}
RI5CY does not feature a full level 1 cache. Instead it contains a 4-instruction deep prefetch buffer inside the instruction fetch stage. This buffer is able to preload up to 4 instructions for execution and is used as a minimalist loop buffer for the \ac{HWL} implementation described in section \ref{sub:plat/ip/ctrl}.

\subsection{Control flow}
    \label{sub:plat/ip/ctrl}
RI5CY implements a simple branch not taken prediction strategy. However, in order to reduce branching overhead, RI5CY implements a \acl{HWL} (also called zero-overhead-loops) extension to the RISC-V \ac{ISA}. The \texttt{lp.setup} instructions allows for single instruction setup of a hardware loop, additional instructions \texttt{lp.start}, \texttt{lp.end}, \texttt{lp.count}, and \texttt{lp.counti} allow for explicit write access other registers used for hardware looping. Subsequent loop iterations are handled by the instruction fetch stage and thus cause no stalls in the pipeline as long as loop instructions fit inside the prefetch buffer. A \ac{HWL} based jump is executed when the different between the program counter and the loop end point stored in the \ac{HWL} registers is zero, as long as the loop counter has not reached zero. When the counter reaches zero, normal execution is resumed. The \ac{HWL} controller in RI5SCY is configured to support 2 levels of nested loops, as diminishing speedup to area increase was observed at higher levels \cite{gautschiNearThresholdRISCVCore2017}.

Apart from \ac{DSP} calculations, the inclusion of \acp{HWL} has also shown to provide significant speedups for other loop heavy calculations. Experiments by Vre\v{c}a et.al. \cite{vrecaAcceleratingDeepLearning2020} have shown that the inclusion of \acp{HWL} alone have provided a 29\% reduction in clock cycle count compared to a baseline with no optimizations (loop unrolling, \acp{HWL}, dot product).

\subsection{Floating point support}
    \label{sub:plat/ip/fpu}
The \ac{FPU} is enabled for the experiments in this thesis. RI5CY uses a slimmed down version of FPnew, a highly configurable open-source multiformat floating point unit \cite{machFPnewOpenSourceMultiformat2021}. FPnew is split into four different data paths, each of them having configurable datapath depth and width, and supports transprecision computing \cite{malossiTransprecisionComputingParadigm2018}. In addition to 32 bit single precision (FP32), and 64 bit double precision (FP64) it supports half-precision (FP16), 16 bit bfloats (FP16alt), as well as an 8 bit custom format (FP8). For RI5CY, only support for FP32, FP16, and FP16alt is enabled. The four data paths implement the functions \ac{ADDMUL}, \ac{DIVSQRT}, \ac{COMP}, and \ac{CONV} respectively. These datapaths can be either generated in parallel to support one data format per lane or merged to be multiformat. They can also be disabled completely, if required. For RI5CY, \ac{ADDMUL} and \ac{COMP} are enabled in merged mode to save power and area allowing one FP32 operation or a packed vector of either 2 FP16 or FP16alt, \ac{COMP} is implemented in parallel mode allowing for one FP32 operation or a packed vector of either 2 FP16 or FP16alt, and \ac{DIVSQRT} is disabled outright. All pipelines have a depth of 1 as clock requirements are relatively relaxed for smaller \acp{MCU} like RI5CY, so floating point operations can complete within a single cycle. 

\section{Xilinx ZYNQ SoC}


% Render bibliograhy and acronyms if rendered standalone
\isstandalone
\bibliographystyle{IEEEtran}
\bibliography{bibliography}
\subfile{abbreviations.tex}
\fi

\end{document} 
